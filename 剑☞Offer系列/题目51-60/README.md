#### 51 构建乘积数组（Medium，数组）
> 此题目为给定一个数组`A[0,1,...,n-1]`,请构建一个数组`B[0,1,...,n-1]`，其中B中的元素`B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]`。不能使用除法。  
百度一下会有很多题解，这里大概说下，B中每个元素可以被拆分成左右两部分相乘l×r，而Bi的左部分又可以被Bi-1的左部分表示，即`l_Bi = l_Bi-1 * Ai-1`；同样，Bi的右部分又可以被Bi+1的右部分表示，即`r_Bi = r_Bi+1 * Ai+1`。经过两次遍历即可得出结果。

#### 52 正则表达式匹配（Medium，字符串，递归）
> 此题目为判断一个字符串是否符合一个正则表达式相匹配。  
解决此题的关键是：判断当前字符的下一个字符是否是`*`，若是，则有两种情况需要考虑，若当前字符对应相等，将字符串中字符后移一位或者将模式字符串后移两位，若不相等，模式字符串后移两位继续匹配；否则，若当前字符对应相等，同时将字符串和模式后移一位继续，否则返回false。见代码。

#### 53 表示数值的字符串（Medium，字符串）
> 判断一个字符串是否表示一个数。   
挺恶心的一道题，疯狂匹配模式，不想多说，直接看代码吧，没啥技术含量。

#### 54 字符流中第一个不重复的字符（Easy，字符流）
> 此题目为请实现一个函数用来找出字符流中第一个只出现一次的字符。  
用一个string存字符流，一个辅助数组用于记录每个目前为止每个字符出现的次数。 

#### 55 链表中环的入口结点（Easy，链表）
> 此题目为给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。   
遍历这个链表，用一个map记录每个节点出现的次数，遇到出现两次的节点则返回。

#### 56 删除链表中重复的结点（Easy，链表）
> 此题目为删除一个链表中的重复的节点，包括重复节点本身。  
简单，见代码。

#### 57 二叉树的下一个结点（Medium，树）
> 此题目为给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。   
若该节点有右子树，则返回右子树中最左的子树（中序遍历），否则，判断该节点是否为上一节点的右节点。见代码。

#### 58 对称的二叉树（Easy，树，递归）
> 此题目为实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。  
简单递归可以实现，注意判定条件，看答案之前先好好想想，见代码。

#### 59 按之字形顺序打印二叉树（Medium，树，栈）
> 

#### 60 把二叉树打印成多行（Medium，树，队列）
> 



