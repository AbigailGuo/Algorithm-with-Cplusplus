#### 51 构建乘积数组（Medium，数组）
> 此题目为给定一个数组`A[0,1,...,n-1]`,请构建一个数组`B[0,1,...,n-1]`，其中B中的元素`B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]`。不能使用除法。  
百度一下会有很多题解，这里大概说下，B中每个元素可以被拆分成左右两部分相乘l×r，而Bi的左部分又可以被Bi-1的左部分表示，即`l_Bi = l_Bi-1 * Ai-1`；同样，Bi的右部分又可以被Bi+1的右部分表示，即`r_Bi = r_Bi+1 * Ai+1`。经过两次遍历即可得出结果。

#### 52 正则表达式匹配（Medium，字符串，递归）
> 此题目为判断一个字符串是否符合一个正则表达式相匹配。  
解决此题的关键是：判断当前字符的下一个字符是否是`*`，若是，则有两种情况需要考虑，若当前字符对应相等，将字符串中字符后移一位或者将模式字符串后移两位，若不相等，模式字符串后移两位继续匹配；否则，若当前字符对应相等，同时将字符串和模式后移一位继续，否则返回false。见代码。

#### 53 表示数值的字符串（Medium，字符串）
> 判断一个字符串是否表示一个数。   
挺恶心的一道题，疯狂匹配模式，不想多说，直接看代码吧，没啥技术含量。

#### 54 字符流中第一个不重复的字符（Easy，字符流）
> 此题目为请实现一个函数用来找出字符流中第一个只出现一次的字符。  
用一个string存字符流，一个辅助数组用于记录每个目前为止每个字符出现的次数。 

#### 55 链表中环的入口结点（Easy，链表，快慢指针）
> 此题目为给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。   
使用快慢指针。见代码。

#### 56 删除链表中重复的结点（Easy，链表）
> 此题目为删除一个链表中的重复的节点，包括重复节点本身。  
简单，见代码。

#### 57 二叉树的下一个结点（Medium，树）
> 此题目为给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。   
若该节点有右子树，则返回右子树中最左的子树（中序遍历），否则，判断该节点是否为上一节点的右节点。见代码。

#### 58 对称的二叉树（Easy，树，递归）
> 此题目为实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。  
简单递归可以实现，注意判定条件，看答案之前先好好想想，见代码。

#### 59 按之字形顺序打印二叉树（Medium，树，栈）
> 此题目为按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。   
本题使用两个栈来循环保存每层的节点，并记录每层的序列。将第一层的节点保存到第一个栈内，将第一层的左右节点保存到第二个栈中，并将第一个栈内节点弹出；再遍历第二个栈中的所有节点并将每个节点的右左节点压入到第一个栈中，并将第二个栈中的节点弹出。循环往复直至两个栈均为空。见代码。

#### 60 把二叉树打印成多行（Medium，树，队列）
> 此题目为从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。  
与上一题完全类似，只是将栈替换成队列，由于其压入和弹出的顺序不同，思路也完全类似，仍然是将每层节点分别存放到两个队列内，自己可以仿照上一题来写，本题的代码是仿照网上的方法来写的，不太容易理解，用两个队列来解决此题是非常直观的解法。



