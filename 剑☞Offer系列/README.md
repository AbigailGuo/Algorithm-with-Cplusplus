## 剑指Offer编程题答案集合
[在线刷题网站：牛客网剑指Offer](https://www.nowcoder.com/ta/coding-interviews?page=1)  
以下是对每道题目涉及算法的简单解释（其中难易程度由本人瞎jb给出，仅供参考）：

#### 01 二维数组的查找（Easy，数组）
> 此题目为有序二维数组查找问题，判断该二维数组中是否含有某个目标整数。  
我们从最右上角元素开始查找判断，若该元素比目标整数小，则该行剩余元素均比目标小，下移一位；反之则该列剩余元素均比目标大，左移一位，直至找到目标元素或行列的某一下标越界。

#### 02 替换空格（Easy，字符串）
> 此题目为将一个字符串（char\*）中的所有空格**原地**替换为`%20`，不得定义另一辅助数组。  
首先我们计算字符串中有多少个空格，得到新字符串的长度，将字符串中原有字符逐个后移。

#### 03 从尾到头打印链表（Medium，链表，递归（回溯））
> 注意是**从尾到头**打印，我么可以利用递归或是回溯的算法思想，在回溯的过程中将值存放在一个全局数组里面。

#### 04 重建二叉树（Medium，树，递归）
> 此题目为根据一棵树的“前序遍历”和“中序遍历”结果（假设不含重复元素），重建该二叉树。  
通过简单的递归可以解决，注意“前序遍历”的第一个元素即为根节点元素，“中序遍历”又根据根节点将结果分为左子数“中序遍历”和右子数“中序遍历”，这样便可以从根开始重构二叉树。

#### 05 用两个栈实现队列（Easy，栈和队列）
> 此题目为用两个栈（stack，先进后出FILO）实现队列（queue，先进先出FIFO）的功能。  
见代码，略。

#### 06	旋转数组的最小数字（Easy，查找和排序）
> 此题目为寻找一个旋转数组中的最小数字。  
通过遍历查找不满足递增顺序的接点处数字。

#### 07 斐波那契数列（Easy，斐波那契）
> 简单利用斐波那契数列的生成规则，`f[n] = f[n-1] + f[n-2], f[0] = 0, f[1] = 1` 

#### 08 跳台阶（Medium，递归）
> 此题目为青蛙一次可以跳1级也可以跳2级台阶，问跳上一个n级台阶共有多少种跳法。  
我们通过递归来解决此题，两个基础情况`n=1`和`n=2`，然后通过递归统计两种情况的跳法之和。

#### 09 变态跳台阶（Medium，递归，贪心，循环）
> 此题目为青蛙一次可以跳1级也可以跳2级也可以跳n级台阶，问跳上一个n级台阶共有多少种跳法。    
我可以发现`f(n) = 1（直接跳） + f(n-1) + f(n-2) + ... + f(1)`，因此可以用简单的循环来解决此问题，代码较长但容易理解；另一种通过递归实现贪心，我们发现规律`f(1) = 1, f(2) = 2, f(3) = 4, f(4) = 8, ... `即`f(n) = 2*f(n-1)`，当`n=1`时返回`1`，代码简洁。

#### 10 矩形覆盖（Medium，递归，斐波那契）
> 此题目为用`2*1`的矩形去覆盖一个`2*n`的大矩形总共有多少种方法。  
试几个例子发现：`f(0) = 0, f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5, ...`从`n=2`开始，有点斐波那契数列的意思，然后就可以了。

#### 11 二进制中1的个数（Medium，位运算）
> 此题目为计算一个整数的二进制表示中1的个数，负数用补码表示。  
首先，我们要知道什么是[补码及其表示方式](https://blog.csdn.net/zl10086111/article/details/80907428)。其次，要知道计算机中的负数以补码形式存储。我们将这个整数与1（00000001）做位运算：`&`，并将1循环右移`>>`，逐个计算1的个数。

#### 12 数值的整数次方（Medium，快速幂）
> 此题目为计算一个double类型浮点数的整数次幂。  
我们使用**快速幂**算法，一种快速求幂的算法，`2^n = 2^(n/2) * 2^(n/2)`构成递推关系。注意这里指数的正负。

#### 13 调整数组顺序使奇数位于偶数前面（Easy，数组）
> 此题目为调整一个整数数组中的数字顺序，使所有奇数均位于偶数的前面，保持奇数之间和偶数之间的相对顺序不变（这里双指针无法解决）。  
我使用的两个辅助数组，虽然看起来很傻但是AC了。

#### 14 链表中倒数第k个结点（Medium，链表，快慢指针）
> 此题目为返回一个链表的倒数第k个节点。  
我们一下子就可以想到遍历一遍用一个vector存储然后直接输出倒数第k个节点，不过这样空间复杂度较高。本题的解法是利用两个指针（**快慢指针**），所谓的快慢指针就是定义两根指针，移动的速度一快一慢，以此来制造出自己想要的差值。这个差值可以让我们找到链表上相应的节点。以本题为例，我们先让快指针先“跑”k步，制造出这个插值k，然后快慢指针同时跑，当快指针再跑len-k步时到达链表尾，此时慢指针恰好跑到该链表的倒数第k个节点。

#### 15 反转链表（Easy，链表）
> 此题目为返回一个链表的反转链表的表头。  
利用三个指针newHead, pHead, temp向前滚动反转即可解决。

#### 16 合并两个排序的链表（Medium，链表，递归）
> 此题目为合并两个有序链表，并返回新链表表头。  
我们使用递归来解题，在每个递归中两个链表的较小的那个为newHead，而newHead的next即为下一个递归的返回值，见代码。

#### 17 树的子结构（Medium，树，递归）
> 此题目为给定两棵二叉树A，B，判断B是不是A的子结构（约定空树不是任一个树的子结构）。  
我们使用递归来解题， 递归遍历A的所有节点与B的根节点进行匹配，在每个匹配中再使用递归判断A节点左右节点与B节点的左右节点是否相匹配，见代码。

#### 18 二叉树的镜像（Easy，树，递归）
> 此题目为将给定的二叉树变换为其镜像二叉树。   
通过简单的递归操作即可解决。

#### 19 顺时针打印矩阵（Easy，数组）
> 此题目为将一个二维数组顺时针打印出来。  
思路很简单，就是写程序的时候有点绕，见代码。

#### 20 包含min函数的栈（Medium，栈）
> 此题目为定义栈（stack）的数据结构（FILO），并在`O(1)`时间内找到当前栈的最小值。  
此题通过两个栈联合解决，其中dmin栈用于保存data栈中每个状态（push，pop）下的最小值，见代码。

#### 21 栈的压入弹出序列（Medium，栈，过程模拟）
> 此题目为给定两个整数序列，一个代表栈的压入序列，判断另一个序列是否为该栈的弹出序列。  
有两种方法AC这道题，一种是保证弹出序列中的数字要保持其在压入序列中的相对位置不变，举个例子，如压入序列为{1，2，3，4，5}， 则{4，5，3，2，1}是其对应的一个弹出序列，其中3，2，1的相对位置没有发生变化，因为4被首先弹出，说明3，2，1已被压入栈，而弹出的顺序3一定比2先弹出来，而2一定比1先弹出来，4后面的数字可以在4后的任一位置弹出，不过该方法实现起来较为复杂；另一种方法是简单的利用一个栈按照给定的弹出序列模拟一遍压入弹出过程，若不与压入序列产生冲突则说明是，见代码。

#### 22 从上往下打印二叉树（Medium，树，队列，广度优先搜索（BFS），层序遍历）
> 此题目为从左到右层序遍历一棵二叉树的每个节点，即广度优先搜索。   
通常我们使用队列（queue）来实现BFS，将每层节点压入一个队列中，然后记录下队列首元素的值，并从队首弹出，压入其左右子树，直至队列为空。见代码。

#### 23 二叉搜索树的后序遍历序列（Medium，树，递归）
> 此题目为判断一个整数数组是否是一棵二叉搜索树的后序遍历序列，无重复数字。  
二叉搜索树的特点是节点左孩子的值<节点值<节点右孩子的值，其中序遍历为一个递增序列。后序遍历的特点是序列的最后一个元素为根节点，比该元素大的为其左子树的后序遍历序列，比该元素小的为其右子树的后序遍历序列，若其子序列中有元素值与该规则产生冲突则该序列不是一棵二叉搜索树的后序遍历序列。

#### 24 二叉树中和为某一值的路径（Hard，树，递归，回溯）
> 此题目为将二叉树中和为某一目标值的从根节点到叶节点的全部路径储存起来。  
我们采用递归的方法，终止条件为判断到叶子节点，若这一路径的和为目标值，则将这一路径储存起来，并在回溯过程将当前节点弹出。见代码。

#### 25 复杂链表的复制（Hard，链表）
> 此题目为给定一个复杂链表，该复杂链表复杂在每个节点不单含有next指向下一个节点，它还包含一个random节点随机的指向任意一个节点，我们的任务是将其复制一份新的链表并返回新链表表头。  
该问题乍一看似乎很简单，就是生成一个一模一样的链表填值就可以了，不过仔细想下去，这样做无法处理random节点问题。该题的解法分为三步，第一步复制，遍历该链表的同时在每个节点的后面复制一份该节点，即由1->2->3->NULL变换为1->1->2->2->3->3->NULL；第二步赋值，给复制的每个节点的random指向的节点赋值；第三步拆分，将复制的全部节点从原链表中差分出来，得到新的一份一模一样的链表。见代码。

#### 26 二叉搜索树与双向链表（Medium，链表，树，递归）
> 此题目为将一棵给定的二叉搜索树转换为一个有序的双向链表。  
我们知道二叉搜索树的中序遍历是个有序数列，我们以此为出发点，中序遍历构建双向链表。见代码。

#### 27 字符串的排列（Hard，字符串，递归，回溯，动态规划）
> 此题目为按字典顺序打印出给定字符串中字符的全排列。  
这道题还挺难的，网上看了视频题解才仿照做了出来，即使我第二遍再看此问题还是懵的。OK，大概讲一下，总体来说是显得到所有排列的结果之后再排序输出。在得到所有排列结果的过程中，一个思想就是字符串中的每个字符在每个位置都出现了一遍，emmm，见代码。

#### 28 数组中出现次数超过一半的数字（Easy，数组）
> 此题目为找出一个数组中出现次数超过数组长度一半的那个元素，没有则扣0。   
非常简单的一道题，直接用map计数即可。

#### 29 最小的K个数（Medium，数组，红黑树，最大堆）
> 此题目为给定n个整数，找出其中最小的K个整数。   
该题考察了红黑树，最大堆的数据结构问题。利用其插入（insert），删除（erase）操作的时间复杂度为O(logn)及最大堆的性质来AC这道题。  

#### 30 连续子数组的最大和（Medium，数组）
> 此题目为计算一个包含正负整数的数组中的连续字串的最大和。   
最核心的思想就是：只要当前连续字串和大于0，就可以继续延长该字串，否则重新开始一个新的字串，并记录这一过程中出现的所有连续字串和的最大值。见代码。
