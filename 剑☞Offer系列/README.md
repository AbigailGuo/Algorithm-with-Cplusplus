## 剑指Offer编程题答案集合
[在线刷题网站：牛客网剑指Offer](https://www.nowcoder.com/ta/coding-interviews?page=1)  
以下是对每道题目涉及算法的简单解释（其中难易程度由本人瞎jb给出，仅供参考）：

#### 01 二维数组的查找（Easy，数组）
> 此题目为有序二维数组查找问题，判断该二维数组中是否含有某个目标整数。  
我们从最右上角元素开始查找判断，若该元素比目标整数小，则该行剩余元素均比目标小，下移一位;反之则该列剩余元素均比目标大，左移一位，直至找到目标元素或行列的某一下标越界。

#### 02 替换空格（Easy，字符串）
> 此题目为将一个字符串（char\*）中的所有空格**原地**替换为`%20`，不得定义另一辅助数组。  
首先我们计算字符串中有多少个空格，得到新字符串的长度，将字符串中原有字符逐个后移。

#### 03 从尾到头打印链表（Medium，链表，递归（回溯））
> 注意是**从尾到头**打印，我么可以利用递归或是回溯的算法思想，在回溯的过程中将值存放在一个全局数组里面。

#### 04 重建二叉树（Medium，树，递归）
> 此题目为根据一棵树的“前序遍历”和“中序遍历”结果（假设不含重复元素），重建该二叉树。  
通过简单的递归可以解决，注意“前序遍历”的第一个元素即为根节点元素，“中序遍历”又根据根节点将结果分为左子数“中序遍历”和右子数“中序遍历”，这样便可以从根开始重构二叉树。

#### 05 用两个栈实现队列（Easy，栈和队列）
> 此题目为用两个栈（stack，先进后出FILO）实现队列（queue，先进先出FIFO）的功能。  
见代码，略。

#### 06	旋转数组的最小数字（Easy，查找和排序）
> 此题目为寻找一个旋转数组中的最小数字。  
通过遍历查找不满足递增顺序的接点处数字。

#### 07 斐波那契数列（Easy，斐波那契）
> 简单利用斐波那契数列的生成规则，`f[n] = f[n-1] + f[n-2], f[0] = 0, f[1] = 1` 

#### 08 跳台阶（Medium，递归）
> 此题目为青蛙一次可以跳1级也可以跳2级台阶，问跳上一个n级台阶共有多少种跳法。  
我们通过递归来解决此题，两个基础情况`n=1`和`n=2`，然后通过递归统计两种情况的跳法之和。

#### 09 变态跳台阶（Medium，递归，贪心，循环）
> 此题目为青蛙一次可以跳1级也可以跳2级也可以跳n级台阶，问跳上一个n级台阶共有多少种跳法。    
我可以发现`f(n) = 1（直接跳） + f(n-1) + f(n-2) + ... + f(1)`，因此可以用简单的循环来解决此问题，代码较长但容易理解；另一种通过递归实现贪心，我们发现规律`f(1) = 1, f(2) = 2, f(3) = 4, f(4) = 8, ... `即`f(n) = 2*f(n-1)`，当`n=1`时返回`1`，代码简洁。

#### 10 矩形覆盖（Medium，递归，斐波那契）
> 此题目为用`2*1`的矩形去覆盖一个`2*n`的大矩形总共有多少种方法。  
试几个例子发现：`f(0) = 0, f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5, ...`从`n=2`开始，有点斐波那契数列的意思，然后就可以了。

#### 11 二进制中1的个数（Medium，位运算）
> 此题目为计算一个整数的二进制表示中1的个数，负数用补码表示。  
首先，我们要知道什么是[补码及其表示方式](https://blog.csdn.net/zl10086111/article/details/80907428)。其次，要知道计算机中的负数以补码形式存储。我们将这个整数与1（00000001）做位运算：`&`，并将1循环右移`>>`，逐个计算1的个数。

#### 12 数值的整数次方（Medium，快速幂）
> 此题目为计算一个double类型浮点数的整数次幂。  
我们使用**快速幂**算法，一种快速求幂的算法，`2^n = 2^(n/2) * 2^(n/2)`构成递推关系。注意这里指数的正负。

#### 13 调整数组顺序使奇数位于偶数前面（Easy，数组）
> 此题目为调整一个整数数组中的数字顺序，使所有奇数均位于偶数的前面，保持奇数之间和偶数之间的相对顺序不变（这里双指针无法解决）。  
我使用的两个辅助数组，虽然看起来很傻但是AC了。

#### 14 链表中倒数第k个结点（Medium，链表，快慢指针）
> 此题目为返回一个链表的倒数第k个节点。  
我们一下子就可以想到遍历一遍用一个vector存储然后直接输出倒数第k个节点，不过这样空间复杂度较高。本题的解法是利用两个指针（**快慢指针**），所谓的快慢指针就是定义两根指针，移动的速度一快一慢，以此来制造出自己想要的差值。这个差值可以让我们找到链表上相应的节点。以本题为例，我们先让快指针先“跑”k步，制造出这个插值k，然后快慢指针同时跑，当快指针再跑len-k步时到达链表尾，此时慢指针恰好跑到该链表的倒数第k个节点。

#### 15 反转链表（Easy，链表）
> 此题目为返回一个链表的反转链表的表头。  
利用三个指针newHead, pHead, temp向前滚动反转即可解决。

#### 16 合并两个排序的链表（Medium，链表，递归）
> 此题目为合并两个有序链表，并返回新链表表头。  
我们使用递归来解题，在每个递归中两个链表的较小的那个为newHead，而newHead的next即为下一个递归的返回值，见代码。

#### 17 树的子结构（Medium，树，递归）
> 此题目为给定两棵二叉树A，B，判断B是不是A的子结构（约定空树不是任一个树的子结构）。  
我们使用递归来解题， 递归遍历A的所有节点与B的根节点进行匹配，在每个匹配中再使用递归判断A节点左右节点与B节点的左右节点是否相匹配，见代码。

#### 18 二叉树的镜像（Easy，树，递归）
> 此题目为将给定的二叉树变换为其镜像二叉树。   
通过简单的递归操作即可解决。

#### 19 顺时针打印矩阵（Easy，数组）
> 此题目为将一个二维数组顺时针打印出来。  
思路很简单，就是写程序的时候有点绕，见代码。

#### 20 包含min的栈（Medium，栈）
> 此题目为定义栈（stack）的数据结构（FILO），并在`O(1)`时间内找到当前栈的最小值。  
此题通过两个栈联合解决，其中dmin栈用于保存data栈中每个状态（push，pop）下的最小值，见代码。
