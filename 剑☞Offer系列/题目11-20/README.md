#### 11 二进制中1的个数（Medium，位运算）
> 此题目为计算一个整数的二进制表示中1的个数，负数用补码表示。  
首先，我们要知道什么是[补码及其表示方式](https://blog.csdn.net/zl10086111/article/details/80907428)。其次，要知道计算机中的负数以补码形式存储。我们将这个整数与1（00000001）做位运算：`&`，并将1循环左移`<<`，逐个计算1的个数。

#### 12 数值的整数次方（Medium，快速幂）
> 此题目为计算一个double类型浮点数的整数次幂。  
我们使用**快速幂**算法，一种快速求幂的算法，`2^n = 2^(n/2) * 2^(n/2)`构成递推关系。注意这里指数的正负。

#### 13 调整数组顺序使奇数位于偶数前面（Easy，数组）
> 此题目为调整一个整数数组中的数字顺序，使所有奇数均位于偶数的前面，保持奇数之间和偶数之间的相对顺序不变（这里双指针无法解决）。  
我使用的两个辅助数组，虽然看起来很傻但是AC了。

#### 14 链表中倒数第k个结点（Medium，链表，快慢指针）
> 此题目为返回一个链表的倒数第k个节点。  
我们一下子就可以想到遍历一遍用一个vector存储然后直接输出倒数第k个节点，不过这样空间复杂度较高。本题的解法是利用两个指针（**快慢指针**），所谓的快慢指针就是定义两根指针，移动的速度一快一慢，以此来制造出自己想要的差值。这个差值可以让我们找到链表上相应的节点。以本题为例，我们先让快指针先“跑”k步，制造出这个插值k，然后快慢指针同时跑，当快指针再跑len-k步时到达链表尾，此时慢指针恰好跑到该链表的倒数第k个节点。

#### 15 反转链表（Easy，链表）
> 此题目为返回一个链表的反转链表的表头。  
利用三个指针newHead, pHead, temp向前滚动反转即可解决。

#### 16 合并两个排序的链表（Medium，链表，递归）
> 此题目为合并两个有序链表，并返回新链表表头。  
我们使用递归来解题，在每个递归中两个链表的较小的那个为newHead，而newHead的next即为下一个递归的返回值，见代码。

#### 17 树的子结构（Medium，树，递归）
> 此题目为给定两棵二叉树A，B，判断B是不是A的子结构（约定空树不是任一个树的子结构）。  
我们使用递归来解题，递归遍历A的所有节点与B的根节点进行匹配，在每个匹配中再使用递归判断A节点左右节点与B节点的左右节点是否相匹配，见代码。

#### 18 二叉树的镜像（Easy，树，递归）
> 此题目为将给定的二叉树变换为其镜像二叉树。   
通过简单的递归操作即可解决。

#### 19 顺时针打印矩阵（Easy，数组）
> 此题目为将一个二维数组顺时针打印出来。  
思路很简单，就是写程序的时候有点绕，见代码。

#### 20 包含min函数的栈（Medium，栈）
> 此题目为定义栈（stack）的数据结构（FILO），并在`O(1)`时间内找到当前栈的最小值。  
此题通过两个栈联合解决，其中dmin栈用于保存data栈中每个状态（push，pop）下的最小值，见代码。
 
